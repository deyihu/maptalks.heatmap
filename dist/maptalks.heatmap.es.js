/*!
 * maptalks.heatmap v0.6.2
 * LICENSE : MIT
 * (c) 2016-2022 maptalks.org
 */
import*as t from"maptalks";var e={exports:{}};!function(t){function a(t){if(!(this instanceof a))return new a(t);this._canvas=t="string"==typeof t?document.getElementById(t):t,this._ctx=t.getContext("2d"),this._width=t.width,this._height=t.height,this._max=1,this._data=[]}e.exports=a,a.prototype={defaultRadius:25,defaultGradient:{.4:"blue",.6:"cyan",.7:"lime",.8:"yellow",1:"red"},data:function(t){return this._data=t,this},max:function(t){return this._max=t,this},add:function(t){return this._data.push(t),this},clear:function(){return this._data=[],this},radius:function(t,e){e=void 0===e?15:e;var a=this._circle=this._createCanvas(),i=a.getContext("2d"),s=this._r=t+e;return a.width=a.height=2*s,i.shadowOffsetX=i.shadowOffsetY=2*s,i.shadowBlur=e,i.shadowColor="black",i.beginPath(),i.arc(-s,-s,t,0,2*Math.PI,!0),i.closePath(),i.fill(),this},resize:function(){this._width=this._canvas.width,this._height=this._canvas.height},gradient:function(t){var e=this._createCanvas(),a=e.getContext("2d"),i=a.createLinearGradient(0,0,0,256);for(var s in e.width=1,e.height=256,t)i.addColorStop(+s,t[s]);return a.fillStyle=i,a.fillRect(0,0,1,256),this._grad=a.getImageData(0,0,1,256).data,this},draw:function(t){this._circle||this.radius(this.defaultRadius),this._grad||this.gradient(this.defaultGradient);var e=this._ctx;e.clearRect(0,0,this._width,this._height);for(var a,i=0,s=this._data.length;i<s;i++)a=this._data[i],e.globalAlpha=Math.max(a[2]/this._max,void 0===t?.05:t),e.drawImage(this._circle,a[0]-this._r,a[1]-this._r);var r=e.getImageData(0,0,this._width,this._height);return this._colorize(r.data,this._grad),e.putImageData(r,0,0),this},_colorize:function(t,e){for(var a,i=0,s=t.length;i<s;i+=4)(a=4*t[i+3])&&(t[i]=e[a],t[i+1]=e[a+1],t[i+2]=e[a+2])},_createCanvas:function(){return"undefined"!=typeof document?document.createElement("canvas"):new this._canvas.constructor}}}();var a=e.exports;const i={"max":1,"gradient":{.4:"blue",.6:"cyan",.7:"lime",.8:"yellow",1:"red"},"radius":25,"blur":15,"heatValueScale":1,"minOpacity":.05};class s extends t.Layer{constructor(t,e,a){Array.isArray(e)||(a=e,e=null),super(t,a),this._heats=e||[]}getData(){return this._heats}setData(t){return this._heats=t||[],this.redraw()}addPoint(e){return e?(e[0]&&Array.isArray(e[0])?t.Util.pushIn(this._heats,e):this._heats.push(e),this.redraw()):this}onConfig(t){for(const e in t)if(i[e])return this.redraw();return this}redraw(){const t=this._getRenderer();return t&&(t.clearHeatCache(),t.setToRedraw()),this}isEmpty(){return!this._heats.length}clear(){return this._heats=[],this.redraw(),this.fire("clear"),this}toJSON(e){e||(e={});const a={"type":this.getJSONType(),"id":this.getId(),"options":this.config()},i=this.getData();if(e.clipExtent){let s=new t.Extent(e.clipExtent);const r=this._getHeatRadius();r&&(s=s._expand(r));const h=[];for(let e=0,a=i.length;e<a;e++)s.contains(new t.Coordinate(i[e][0],i[e][1]))&&h.push(i[e]);a.data=h}else a.data=i;return a}static fromJSON(t){return t&&"HeatLayer"===t.type?new s(t.id,t.data,t.options):null}_getHeatRadius(){return this._getRenderer()?this._getRenderer()._heatRadius:null}}s.mergeOptions(i),s.registerJSONType("HeatLayer"),s.registerRenderer("canvas",class extends t.renderer.CanvasRenderer{draw(){const t=this.getMap(),e=this.layer,i=t.getContainerExtent();let s=this.prepareCanvas(),r=i;if(s){if(s=s.convertTo((e=>t._pointToContainerPoint(e))),!s.intersects(i))return void this.completeRender();r=i.intersection(s)}this._heater||(this._heater=a(this.canvas)),this._heater.radius(e.options.radius||this._heater.defaultRadius,e.options.blur),e.options.gradient&&this._heater.gradient(e.options.gradient),this._heater.max(e.options.max),this._heatViews||(this._heatViews=[]);const h=e.getData();if(0===h.length)return void this.completeRender();const n=this._heatData(h,r);this._heater.data(n).draw(e.options.minOpacity),this.completeRender()}drawOnInteracting(){this.draw()}_heatData(e,a){const i=this.getMap(),s=this.layer,r=i.getProjection(),h=[],n=this._heater._r,o=void 0===s.options.max?1:s.options.max,d=n/2,c=[],l=i.offsetPlatform(),u=l.x%d,_=l.y%d;let g,p,f,w,m,v;a=a.expand(n).convertTo((e=>new t.Point(i._containerPointToPrj(e)))),this._heatRadius=n;for(let h=0,n=e.length;h<n;h++)g=e[h],this._heatViews[h]||(this._heatViews[h]=r.project(new t.Coordinate(g[0],g[1]))),p=this._heatViews[h],a.contains(p)&&(p=i._prjToContainerPoint(p),w=Math.floor((p.x-u)/d)+2,m=Math.floor((p.y-_)/d)+2,v=(void 0!==g[2]?+g[2]:.1)*s.options.heatValueScale,c[m]=c[m]||[],f=c[m][w],f?(f[0]=(f[0]*f[2]+p.x*v)/(f[2]+v),f[1]=(f[1]*f[2]+p.y*v)/(f[2]+v),f[2]+=v):c[m][w]=[p.x,p.y,v]);for(let t=0,e=c.length;t<e;t++)if(c[t])for(let e=0,a=c[t].length;e<a;e++)f=c[t][e],f&&h.push([Math.round(f[0]),Math.round(f[1]),Math.min(f[2],o)]);return h}onZoomEnd(){delete this._heatViews,super.onZoomEnd.apply(this,arguments)}onResize(){super.onResize.apply(this,arguments),this.canvas&&(this._heater._width=this.canvas.width,this._heater._height=this.canvas.height)}onRemove(){this.clearHeatCache(),delete this._heater}clearHeatCache(){delete this._heatViews}});export{s as HeatLayer};"undefined"!=typeof console&&console.log("maptalks.heatmap v0.6.2");
